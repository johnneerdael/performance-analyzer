"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultReportGenerator = void 0;
/**
 * Default implementation of the ReportGenerator interface
 * Generates comprehensive markdown reports from analysis results
 */
class DefaultReportGenerator {
    constructor() {
        // Map to store dataset name to display name mappings
        this.datasetDisplayNames = new Map();
    }
    /**
     * Set the dataset display name mapping
     * @param datasets Array of datasets with name and displayName properties
     */
    setDatasetDisplayNames(datasets) {
        this.datasetDisplayNames.clear();
        datasets.forEach(dataset => {
            if (dataset.displayName) {
                this.datasetDisplayNames.set(dataset.name, dataset.displayName);
            }
        });
    }
    /**
     * Get the display name for a configuration
     * @param configName The configuration name
     * @returns The display name if available, otherwise the original name
     */
    getConfigurationDisplayName(configName) {
        return this.datasetDisplayNames.get(configName) || configName;
    }
    /**
     * Generate a complete markdown report from analysis results
     * @param analysis The analysis results to include in the report
     * @returns A promise that resolves to the generated markdown report
     */
    async generateReport(analysis) {
        try {
            // Prepare data for template
            const templateData = this.prepareTemplateData(analysis);
            // Generate the report header and executive summary
            let report = this.generateReportHeader(analysis);
            report += "\n\n" + this.createExecutiveSummary(analysis);
            report += "\n\n" + this.generateConfigurationOverview(analysis);
            report += "\n\n" + this.generateComparisonTables(analysis);
            // Generate the detailed tables
            report += "\n\n## Detailed Performance Analysis\n\n";
            report += this.generateBandwidthTable(analysis.iperfAnalysis.bandwidthComparison);
            report += "\n\n" + this.generateLatencyTable(analysis.iperfAnalysis.latencyAnalysis);
            report += "\n\n" + this.generateReliabilityTable(analysis.iperfAnalysis.reliabilityMetrics);
            report += "\n\n" + this.generateCpuUtilizationTable(analysis.iperfAnalysis.cpuUtilizationAnalysis);
            report += "\n\n" + this.generateDnsPerformanceTable(analysis.dnsAnalysis.performanceMetrics);
            report += "\n\n" + this.generateDomainRankingTable(analysis.dnsAnalysis.domainRankings);
            // Generate the advanced analysis tables
            report += "\n\n## Advanced Performance Analysis\n\n";
            report += "These tables provide more detailed analysis of specific performance metrics to help identify patterns and correlations.\n\n";
            report += this.generateDetailedBandwidthAnalysis(analysis.iperfAnalysis.bandwidthComparison);
            report += "\n\n" + this.generateJitterAnalysis(analysis.iperfAnalysis.latencyAnalysis);
            report += "\n\n" + this.generateRetransmissionAnalysis(analysis.iperfAnalysis.reliabilityMetrics);
            report += "\n\n" + this.generatePerformanceCorrelationMatrix(analysis);
            // Add the rest of the report
            report += "\n\n" + this.createVisualizationDescriptions(analysis);
            report += "\n\n" + this.generateAnomaliesSection(analysis);
            report += "\n\n" + this.generateRecommendationsSection(analysis);
            // Add the footer
            report += "\n\n\n---\n\n*Report generated by Network Performance Analyzer on " + new Date().toISOString() + "*";
            return report;
        }
        catch (error) {
            console.error("Error generating report:", error);
            const errorMessage = error.message || "Unknown error";
            throw new Error(`Failed to generate report: ${errorMessage}`);
        }
    }
    /**
     * Generate the report header with title and date
     * @param analysis The analysis results
     * @returns The header as a markdown string
     */
    generateReportHeader(analysis) {
        const date = new Date().toISOString().split("T")[0];
        return [
            "# Network Performance Analysis Report",
            "",
            `**Date:** ${date}`,
            `**Datasets Analyzed:** ${analysis.summary.totalDatasets}`,
            "",
        ].join("\n");
    }
    /**
     * Create an executive summary section for the report
     * @param analysis The analysis results to summarize
     * @returns The executive summary as a markdown string
     */
    createExecutiveSummary(analysis) {
        const { summary } = analysis;
        console.log('[DEBUG] Summary object:', summary);
        console.log('[DEBUG] Optimal configuration from summary:', summary.optimalConfiguration);
        const executiveSummary = [
            "## Executive Summary",
            "",
            "This report presents a comprehensive analysis of network performance across different configurations, focusing on bandwidth, latency, reliability, and DNS resolution performance.",
            "",
            "### Key Findings",
            "",
        ];
        // Add key findings as bullet points
        summary.keyFindings.forEach((finding) => {
            // Replace dataset names with display names in findings
            let updatedFinding = finding;
            this.datasetDisplayNames.forEach((displayName, name) => {
                updatedFinding = updatedFinding.replace(name, displayName);
            });
            executiveSummary.push(`- ${updatedFinding}`);
        });
        executiveSummary.push("");
        executiveSummary.push("### Optimal Configuration");
        executiveSummary.push("");
        executiveSummary.push(`Based on the analysis, the **${this.getConfigurationDisplayName(summary.optimalConfiguration)}** configuration provides the best overall performance.`);
        executiveSummary.push("");
        // Add performance highlights
        executiveSummary.push("### Performance Highlights");
        executiveSummary.push("");
        summary.performanceHighlights.forEach((highlight) => {
            // Replace dataset names with display names in highlights
            let updatedHighlight = highlight;
            this.datasetDisplayNames.forEach((displayName, name) => {
                updatedHighlight = updatedHighlight.replace(name, displayName);
            });
            executiveSummary.push(`- ${updatedHighlight}`);
        });
        return executiveSummary.join("\n");
    }
    /**
     * Generate an overview of the configurations analyzed
     * @param analysis The analysis results
     * @returns The configuration overview as a markdown string
     */
    generateConfigurationOverview(analysis) {
        const { configurationComparison } = analysis;
        const { overallRanking } = configurationComparison;
        const overview = [
            "## Configuration Overview",
            "",
            "The following configurations were analyzed and ranked based on overall performance:",
            "",
            "| Rank | Configuration | Overall Score | Bandwidth Score | Latency Score | Reliability Score |",
            "|------|--------------|--------------|----------------|--------------|------------------|",
        ];
        // Sort configurations by rank
        const sortedConfigs = [...overallRanking].sort((a, b) => a.rank - b.rank);
        sortedConfigs.forEach((config) => {
            overview.push(`| ${config.rank} | ${this.getConfigurationDisplayName(config.configuration)} | ${config.overallScore.toFixed(2)} | ${config.bandwidthScore.toFixed(2)} | ${config.latencyScore.toFixed(2)} | ${config.reliabilityScore.toFixed(2)} |`);
        });
        return overview.join("\n");
    }
    /**
     * Generate detailed performance tables for the report
     * @param analysis The analysis results to tabulate
     * @returns The detailed tables as a markdown string
     */
    /**
     * Generate side-by-side comparison tables for better analysis
     * @param analysis The analysis results
     * @returns The comparison tables as a markdown string
     */
    generateComparisonTables(analysis) {
        // Prepare template data to get the dnsMetrics with displayName
        const templateData = this.prepareTemplateData(analysis);
        const sections = [
            "## Side-by-Side Comparisons",
            "",
            "These tables provide direct comparisons across different configurations to help identify patterns and make informed decisions.",
            "",
            this.generateDnsComparisonTable(templateData.dnsMetrics),
            "",
            this.generateMtuImpactTable(analysis),
            "",
            this.generateDnsServerComparisonTable(analysis),
            "",
            this.generateLoggingImpactTable(analysis),
            "",
            this.generateAnomalyDistributionTable(analysis.anomalies),
        ];
        return sections.join("\n");
    }
    /**
     * Generate a DNS performance comparison table
     * @param metrics The DNS performance metrics
     * @returns The DNS comparison table as a markdown string
     */
    /**
     * Prepare data for the template
     * @param analysis The analysis results
     * @returns The prepared data for the template
     */
    prepareTemplateData(analysis) {
        const { iperfAnalysis, dnsAnalysis, configurationComparison, anomalies } = analysis;
        const { bandwidthComparison, latencyAnalysis, reliabilityMetrics } = iperfAnalysis;
        const { performanceMetrics } = dnsAnalysis;
        const { overallRanking } = configurationComparison;
        // Prepare DNS metrics with slow domains count and display names
        const dnsMetricsWithSlowDomains = performanceMetrics.map(metric => {
            const slowDomains = metric.slowestDomains ?
                metric.slowestDomains.filter(d => d.avgResponseTimeMs > 150) : [];
            return {
                ...metric,
                displayName: this.getConfigurationDisplayName(metric.configuration),
                slowDomainsCount: slowDomains.length,
                successRate: (metric.successRate * 100).toFixed(1)
            };
        });
        // Prepare MTU impact data
        const mtuImpactData = [];
        const configsByMtu = new Map();
        // Group configurations by MTU and DNS server
        overallRanking.forEach(config => {
            const displayName = this.getConfigurationDisplayName(config.configuration);
            const parts = displayName.split('-');
            if (parts.length >= 2 && parts[0] && parts[1]) {
                const dnsServer = parts[0]; // e.g., 'bind9' or 'coredns'
                const mtu = parts[1].replace('mtu', ''); // e.g., '1420' from 'mtu1420'
                const key = `${mtu} (${dnsServer})`;
                if (!configsByMtu.has(key)) {
                    configsByMtu.set(key, []);
                }
                const configList = configsByMtu.get(key);
                if (configList) {
                    configList.push({
                        ...config,
                        displayName,
                        mtu,
                        dnsServer
                    });
                }
            }
        });
        // Create MTU impact data entries
        configsByMtu.forEach((configs, mtuSetting) => {
            if (configs.length > 0) {
                const config = configs[0];
                const bandwidthMetric = bandwidthComparison.find(m => m.configuration === config.configuration);
                const latencyMetric = latencyAnalysis.find(m => m.configuration === config.configuration);
                const reliabilityMetric = reliabilityMetrics.find(m => m.configuration === config.configuration);
                mtuImpactData.push({
                    mtuSetting,
                    avgBandwidth: bandwidthMetric ? bandwidthMetric.avgBandwidthMbps.toFixed(2) : 'N/A',
                    avgLatency: latencyMetric ? latencyMetric.avgLatencyMs.toFixed(2) : 'N/A',
                    jitter: latencyMetric ? latencyMetric.jitterMs.toFixed(2) : 'N/A',
                    packetLoss: reliabilityMetric ? (reliabilityMetric.packetLossRate * 100).toFixed(2) : 'N/A',
                    overallScore: config.overallScore.toFixed(2)
                });
            }
        });
        // Prepare DNS server data
        const dnsServerData = [];
        const configsByServer = new Map();
        // Group configurations by DNS server
        overallRanking.forEach(config => {
            const displayName = this.getConfigurationDisplayName(config.configuration);
            const parts = displayName.split('-');
            if (parts.length >= 1 && parts[0]) {
                const dnsServer = parts[0]; // e.g., 'bind9' or 'coredns'
                if (!configsByServer.has(dnsServer)) {
                    configsByServer.set(dnsServer, []);
                }
                const configList = configsByServer.get(dnsServer);
                if (configList) {
                    configList.push({
                        ...config,
                        displayName
                    });
                }
            }
        });
        // Calculate averages for each DNS server
        configsByServer.forEach((configs, server) => {
            if (configs.length > 0) {
                // Calculate average bandwidth
                const bandwidthValues = configs
                    .map(c => bandwidthComparison.find(m => m.configuration === c.configuration)?.avgBandwidthMbps || 0);
                const avgBandwidth = bandwidthValues.length > 0
                    ? (bandwidthValues.reduce((sum, val) => sum + val, 0) / bandwidthValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average latency
                const latencyValues = configs
                    .map(c => latencyAnalysis.find(m => m.configuration === c.configuration)?.avgLatencyMs || 0);
                const avgLatency = latencyValues.length > 0
                    ? (latencyValues.reduce((sum, val) => sum + val, 0) / latencyValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average DNS response time
                const dnsResponseValues = configs
                    .map(c => performanceMetrics.find(m => m.configuration === c.configuration)?.avgResponseTimeMs || 0);
                const avgDnsResponse = dnsResponseValues.length > 0
                    ? (dnsResponseValues.reduce((sum, val) => sum + val, 0) / dnsResponseValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average packet loss
                const packetLossValues = configs
                    .map(c => {
                    const reliabilityMetric = reliabilityMetrics.find(m => m.configuration === c.configuration);
                    return reliabilityMetric ? reliabilityMetric.packetLossRate * 100 : 0;
                });
                const avgPacketLoss = packetLossValues.length > 0
                    ? (packetLossValues.reduce((sum, val) => sum + val, 0) / packetLossValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average overall score
                const scoreValues = configs.map(c => c.overallScore);
                const avgScore = scoreValues.length > 0
                    ? (scoreValues.reduce((sum, val) => sum + val, 0) / scoreValues.length).toFixed(2)
                    : 'N/A';
                dnsServerData.push({
                    server,
                    avgBandwidth,
                    avgLatency,
                    dnsResponse: avgDnsResponse,
                    packetLoss: avgPacketLoss,
                    overallScore: avgScore
                });
            }
        });
        // Prepare logging impact data
        const loggingImpactData = [];
        const configsByLogging = new Map();
        // Group configurations by logging status
        overallRanking.forEach(config => {
            const displayName = this.getConfigurationDisplayName(config.configuration);
            const parts = displayName.split('-');
            if (parts.length >= 3 && parts[2]) {
                const loggingStatus = parts[2].includes('enabled') ? 'Enabled' : 'Disabled';
                if (!configsByLogging.has(loggingStatus)) {
                    configsByLogging.set(loggingStatus, []);
                }
                const configList = configsByLogging.get(loggingStatus);
                if (configList) {
                    configList.push({
                        ...config,
                        displayName
                    });
                }
            }
        });
        // Calculate averages for each logging status
        configsByLogging.forEach((configs, status) => {
            if (configs.length > 0) {
                // Calculate average bandwidth
                const bandwidthValues = configs
                    .map(c => bandwidthComparison.find(m => m.configuration === c.configuration)?.avgBandwidthMbps || 0);
                const avgBandwidth = bandwidthValues.length > 0
                    ? (bandwidthValues.reduce((sum, val) => sum + val, 0) / bandwidthValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average latency
                const latencyValues = configs
                    .map(c => latencyAnalysis.find(m => m.configuration === c.configuration)?.avgLatencyMs || 0);
                const avgLatency = latencyValues.length > 0
                    ? (latencyValues.reduce((sum, val) => sum + val, 0) / latencyValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average DNS response time
                const dnsResponseValues = configs
                    .map(c => performanceMetrics.find(m => m.configuration === c.configuration)?.avgResponseTimeMs || 0);
                const avgDnsResponse = dnsResponseValues.length > 0
                    ? (dnsResponseValues.reduce((sum, val) => sum + val, 0) / dnsResponseValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average packet loss
                const packetLossValues = configs
                    .map(c => {
                    const reliabilityMetric = reliabilityMetrics.find(m => m.configuration === c.configuration);
                    return reliabilityMetric ? reliabilityMetric.packetLossRate * 100 : 0;
                });
                const avgPacketLoss = packetLossValues.length > 0
                    ? (packetLossValues.reduce((sum, val) => sum + val, 0) / packetLossValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average overall score
                const scoreValues = configs.map(c => c.overallScore);
                const avgScore = scoreValues.length > 0
                    ? (scoreValues.reduce((sum, val) => sum + val, 0) / scoreValues.length).toFixed(2)
                    : 'N/A';
                loggingImpactData.push({
                    status,
                    avgBandwidth,
                    avgLatency,
                    dnsResponse: avgDnsResponse,
                    packetLoss: avgPacketLoss,
                    overallScore: avgScore
                });
            }
        });
        // Prepare anomaly distribution data
        const anomalyDistribution = [];
        const anomalyMap = new Map();
        // Group anomalies by configuration and type
        anomalies.forEach(anomaly => {
            const configName = this.getConfigurationDisplayName(anomaly.configuration);
            if (!anomalyMap.has(configName)) {
                anomalyMap.set(configName, new Map());
            }
            const configAnomalies = anomalyMap.get(configName);
            if (!configAnomalies.has(anomaly.type)) {
                configAnomalies.set(anomaly.type, { count: 0, severities: [] });
            }
            const typeAnomalies = configAnomalies.get(anomaly.type);
            typeAnomalies.count++;
            typeAnomalies.severities.push(anomaly.severity);
        });
        // Format anomaly distribution data
        anomalyMap.forEach((configAnomalies, configuration) => {
            // Format anomaly counts with severity
            const formatAnomalies = (type) => {
                if (!configAnomalies.has(type))
                    return '0';
                const anomalyData = configAnomalies.get(type);
                if (!anomalyData)
                    return '0';
                const { count, severities } = anomalyData;
                const severityCounts = {
                    high: severities.filter(s => s === 'high').length,
                    medium: severities.filter(s => s === 'medium').length,
                    low: severities.filter(s => s === 'low').length
                };
                const parts = [];
                if (severityCounts.high > 0)
                    parts.push(`${severityCounts.high} (high)`);
                if (severityCounts.medium > 0)
                    parts.push(`${severityCounts.medium} (medium)`);
                if (severityCounts.low > 0)
                    parts.push(`${severityCounts.low} (low)`);
                return parts.join(', ');
            };
            const bandwidthAnomalies = formatAnomalies('bandwidth');
            const latencyAnomalies = formatAnomalies('latency');
            const packetLossAnomalies = formatAnomalies('packet_loss');
            const dnsAnomalies = formatAnomalies('dns_failure');
            // Calculate total anomalies
            const totalAnomalies = Array.from(configAnomalies.values())
                .reduce((sum, anomalyData) => sum + anomalyData.count, 0);
            anomalyDistribution.push({
                configuration,
                bandwidthAnomalies,
                latencyAnomalies,
                packetLossAnomalies,
                dnsAnomalies,
                total: totalAnomalies
            });
        });
        // Return the prepared data
        return {
            ...analysis,
            ...analysis.summary,
            date: new Date().toISOString().split('T')[0],
            timestamp: new Date().toISOString(),
            datasetCount: analysis.summary.totalDatasets,
            configurations: overallRanking,
            bandwidthMetrics: bandwidthComparison,
            latencyMetrics: latencyAnalysis,
            dnsMetrics: dnsMetricsWithSlowDomains,
            slowestDomains: dnsAnalysis.domainRankings?.slice(0, 10) || [],
            mtuImpactData,
            dnsServerData,
            loggingImpactData,
            anomalyDistribution
        };
    }
    generateDnsComparisonTable(metrics) {
        // Count domains with response time > 150ms for each configuration
        const domainsOver150ms = metrics.map(metric => {
            const slowDomains = metric.slowestDomains ?
                metric.slowestDomains.filter(d => d.avgResponseTimeMs > 150) : [];
            return {
                configuration: metric.configuration,
                count: slowDomains.length
            };
        });
        const table = [
            "### DNS Performance Comparison",
            "",
            "This table provides a side-by-side comparison of DNS performance metrics across all configurations:",
            "",
            "| Configuration | Avg Response (ms) | Median Response (ms) | Success Rate (%) | Domains with >150ms |",
            "|---------------|------------------|----------------------|------------------|---------------------|",
        ];
        // Sort by average response time
        const sortedMetrics = [...metrics].sort((a, b) => a.avgResponseTimeMs - b.avgResponseTimeMs);
        sortedMetrics.forEach((metric) => {
            const matchingDomain = domainsOver150ms.find(d => d.configuration === metric.configuration);
            const slowDomainsCount = matchingDomain ? matchingDomain.count : 0;
            // Always use displayName if available, otherwise fall back to getConfigurationDisplayName
            const displayName = metric.displayName || this.getConfigurationDisplayName(metric.configuration);
            table.push(`| ${displayName} | ${metric.avgResponseTimeMs.toFixed(2)} | ${metric.medianResponseTimeMs.toFixed(2)} | ${(metric.successRate * 100).toFixed(1)} | ${slowDomainsCount} |`);
        });
        return table.join("\n");
    }
    /**
     * Generate an MTU impact analysis table
     * @param analysis The analysis results
     * @returns The MTU impact table as a markdown string
     */
    generateMtuImpactTable(analysis) {
        const { iperfAnalysis, configurationComparison } = analysis;
        const { bandwidthComparison, latencyAnalysis } = iperfAnalysis;
        const { reliabilityMetrics } = iperfAnalysis;
        const { overallRanking } = configurationComparison;
        // Group configurations by MTU and DNS server
        const configsByMtu = new Map();
        // Extract MTU and DNS server from configuration names
        overallRanking.forEach(config => {
            const displayName = this.getConfigurationDisplayName(config.configuration);
            const parts = displayName.split('-');
            if (parts.length >= 2 && parts[0] && parts[1]) {
                const dnsServer = parts[0]; // e.g., 'bind9' or 'coredns'
                const mtu = parts[1].replace('mtu', ''); // e.g., '1420' from 'mtu1420'
                const key = `${mtu} (${dnsServer})`;
                if (!configsByMtu.has(key)) {
                    configsByMtu.set(key, []);
                }
                const configList = configsByMtu.get(key);
                if (configList) {
                    configList.push({
                        ...config,
                        displayName,
                        mtu,
                        dnsServer
                    });
                }
            }
        });
        // Create table
        const table = [
            "### MTU Impact Analysis",
            "",
            "This table shows the impact of different MTU settings across DNS server implementations:",
            "",
            "| MTU Setting | Avg Bandwidth (Mbps) | Avg Latency (ms) | Jitter (ms) | Packet Loss (%) | Overall Score |",
            "|-------------|----------------------|------------------|-------------|-----------------|---------------|",
        ];
        // Sort by MTU and then by DNS server
        const sortedKeys = Array.from(configsByMtu.keys()).sort((a, b) => {
            const aParts = a.split(' ');
            const bParts = b.split(' ');
            const mtuA = aParts.length > 0 ? parseInt(aParts[0] || '0') : 0;
            const mtuB = bParts.length > 0 ? parseInt(bParts[0] || '0') : 0;
            if (mtuA !== mtuB)
                return mtuA - mtuB;
            return a.localeCompare(b);
        });
        sortedKeys.forEach(key => {
            const configs = configsByMtu.get(key) || [];
            if (configs.length > 0) {
                // Use the first config in each group
                const config = configs[0];
                // Find corresponding bandwidth and latency metrics
                const bandwidthMetric = bandwidthComparison.find(m => m.configuration === config.configuration);
                const latencyMetric = latencyAnalysis.find(m => m.configuration === config.configuration);
                const reliabilityMetric = reliabilityMetrics.find(m => m.configuration === config.configuration);
                // Format metrics with null checks
                const formatMetric = (value, multiplier = 1) => {
                    return value !== undefined ? (value * multiplier).toFixed(2) : 'N/A';
                };
                const avgBandwidth = bandwidthMetric ? formatMetric(bandwidthMetric.avgBandwidthMbps) : 'N/A';
                const avgLatency = latencyMetric ? formatMetric(latencyMetric.avgLatencyMs) : 'N/A';
                const jitter = latencyMetric ? formatMetric(latencyMetric.jitterMs) : 'N/A';
                const packetLoss = reliabilityMetric ? formatMetric(reliabilityMetric.packetLossRate, 100) : 'N/A';
                const overallScore = config.overallScore.toFixed(2);
                table.push(`| ${key} | ${avgBandwidth} | ${avgLatency} | ${jitter} | ${packetLoss} | ${overallScore} |`);
            }
        });
        return table.join("\n");
    }
    /**
     * Generate a DNS server implementation comparison table
     * @param analysis The analysis results
     * @returns The DNS server comparison table as a markdown string
     */
    generateDnsServerComparisonTable(analysis) {
        const { iperfAnalysis, dnsAnalysis, configurationComparison } = analysis;
        const { bandwidthComparison, latencyAnalysis } = iperfAnalysis;
        const { performanceMetrics } = dnsAnalysis;
        const { overallRanking } = configurationComparison;
        // Group configurations by DNS server
        const configsByServer = new Map();
        // Extract DNS server from configuration names
        overallRanking.forEach(config => {
            const displayName = this.getConfigurationDisplayName(config.configuration);
            const parts = displayName.split('-');
            if (parts.length >= 1 && parts[0]) {
                const dnsServer = parts[0]; // e.g., 'bind9' or 'coredns'
                if (!configsByServer.has(dnsServer)) {
                    configsByServer.set(dnsServer, []);
                }
                const configList = configsByServer.get(dnsServer);
                if (configList) {
                    configList.push({
                        ...config,
                        displayName
                    });
                }
            }
        });
        // Create table
        const table = [
            "### DNS Server Implementation Comparison",
            "",
            "This table compares the performance of different DNS server implementations across key metrics:",
            "",
            "| DNS Server | Avg Bandwidth (Mbps) | Avg Latency (ms) | DNS Response (ms) | Packet Loss (%) | Overall Score |",
            "|------------|----------------------|------------------|-------------------|-----------------|---------------|",
        ];
        // Calculate averages for each DNS server
        configsByServer.forEach((configs, dnsServer) => {
            if (configs.length > 0) {
                // Helper function to calculate and format averages
                const calculateAverage = (values) => {
                    return values.length > 0
                        ? (values.reduce((sum, val) => sum + val, 0) / values.length).toFixed(2)
                        : 'N/A';
                };
                // Calculate average bandwidth
                const bandwidthValues = configs
                    .map(c => bandwidthComparison.find(m => m.configuration === c.configuration)?.avgBandwidthMbps || 0);
                const avgBandwidth = calculateAverage(bandwidthValues);
                // Calculate average latency
                const latencyValues = configs
                    .map(c => latencyAnalysis.find(m => m.configuration === c.configuration)?.avgLatencyMs || 0);
                const avgLatency = calculateAverage(latencyValues);
                // Calculate average DNS response time
                const dnsResponseValues = configs
                    .map(c => performanceMetrics.find(m => m.configuration === c.configuration)?.avgResponseTimeMs || 0);
                const avgDnsResponse = calculateAverage(dnsResponseValues);
                // Calculate average packet loss
                const packetLossValues = configs
                    .map(c => {
                    const reliabilityMetric = analysis.iperfAnalysis.reliabilityMetrics.find(m => m.configuration === c.configuration);
                    return reliabilityMetric ? reliabilityMetric.packetLossRate * 100 : 0;
                });
                const avgPacketLoss = calculateAverage(packetLossValues);
                // Calculate average overall score
                const scoreValues = configs.map(c => c.overallScore);
                const avgScore = calculateAverage(scoreValues);
                table.push(`| ${dnsServer} | ${avgBandwidth} | ${avgLatency} | ${avgDnsResponse} | ${avgPacketLoss} | ${avgScore} |`);
            }
        });
        return table.join("\n");
    }
    /**
     * Generate a logging impact analysis table
     * @param analysis The analysis results
     * @returns The logging impact table as a markdown string
     */
    generateLoggingImpactTable(analysis) {
        const { iperfAnalysis, dnsAnalysis, configurationComparison } = analysis;
        const { bandwidthComparison, latencyAnalysis } = iperfAnalysis;
        const { performanceMetrics } = dnsAnalysis;
        const { overallRanking } = configurationComparison;
        // Group configurations by logging status
        const configsByLogging = new Map();
        // Extract logging status from configuration names
        overallRanking.forEach(config => {
            const displayName = this.getConfigurationDisplayName(config.configuration);
            const parts = displayName.split('-');
            if (parts.length >= 3 && parts[2]) {
                const loggingStatus = parts[2].includes('enabled') ? 'Enabled' : 'Disabled';
                if (!configsByLogging.has(loggingStatus)) {
                    configsByLogging.set(loggingStatus, []);
                }
                const configList = configsByLogging.get(loggingStatus);
                if (configList) {
                    configList.push({
                        ...config,
                        displayName
                    });
                }
            }
        });
        // Create table
        const table = [
            "### Logging Impact Analysis",
            "",
            "This table shows the impact of logging configuration on network performance:",
            "",
            "| Logging | Avg Bandwidth (Mbps) | Avg Latency (ms) | DNS Response (ms) | Packet Loss (%) | Overall Score |",
            "|---------|----------------------|------------------|-------------------|-----------------|---------------|",
        ];
        // Calculate averages for each logging status
        configsByLogging.forEach((configs, loggingStatus) => {
            if (configs.length > 0) {
                // Calculate average bandwidth
                const bandwidthValues = configs
                    .map(c => bandwidthComparison.find(m => m.configuration === c.configuration)?.avgBandwidthMbps || 0);
                const avgBandwidth = bandwidthValues.length > 0
                    ? (bandwidthValues.reduce((sum, val) => sum + val, 0) / bandwidthValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average latency
                const latencyValues = configs
                    .map(c => latencyAnalysis.find(m => m.configuration === c.configuration)?.avgLatencyMs || 0);
                const avgLatency = latencyValues.length > 0
                    ? (latencyValues.reduce((sum, val) => sum + val, 0) / latencyValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average DNS response time
                const dnsResponseValues = configs
                    .map(c => performanceMetrics.find(m => m.configuration === c.configuration)?.avgResponseTimeMs || 0);
                const avgDnsResponse = dnsResponseValues.length > 0
                    ? (dnsResponseValues.reduce((sum, val) => sum + val, 0) / dnsResponseValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average packet loss
                const packetLossValues = configs
                    .map(c => {
                    const reliabilityMetric = analysis.iperfAnalysis.reliabilityMetrics.find(m => m.configuration === c.configuration);
                    return reliabilityMetric ? reliabilityMetric.packetLossRate * 100 : 0;
                });
                const avgPacketLoss = packetLossValues.length > 0
                    ? (packetLossValues.reduce((sum, val) => sum + val, 0) / packetLossValues.length).toFixed(2)
                    : 'N/A';
                // Calculate average overall score
                const scoreValues = configs.map(c => c.overallScore);
                const avgScore = scoreValues.length > 0
                    ? (scoreValues.reduce((sum, val) => sum + val, 0) / scoreValues.length).toFixed(2)
                    : 'N/A';
                table.push(`| ${loggingStatus} | ${avgBandwidth} | ${avgLatency} | ${avgDnsResponse} | ${avgPacketLoss} | ${avgScore} |`);
            }
        });
        return table.join("\n");
    }
    /**
     * Generate an anomaly distribution table
     * @param anomalies The performance anomalies
     * @returns The anomaly distribution table as a markdown string
     */
    generateAnomalyDistributionTable(anomalies) {
        // Group anomalies by configuration and type
        const anomalyMap = new Map();
        anomalies.forEach(anomaly => {
            // Always use the display name for the configuration
            const configName = this.getConfigurationDisplayName(anomaly.configuration);
            if (!anomalyMap.has(configName)) {
                anomalyMap.set(configName, new Map());
            }
            const configAnomalies = anomalyMap.get(configName);
            if (!configAnomalies.has(anomaly.type)) {
                configAnomalies.set(anomaly.type, { count: 0, severities: [] });
            }
            const typeAnomalies = configAnomalies.get(anomaly.type);
            typeAnomalies.count++;
            typeAnomalies.severities.push(anomaly.severity);
        });
        // Create table
        const table = [
            "### Anomaly Distribution",
            "",
            "This table summarizes the distribution of anomalies by type and severity across configurations:",
            "",
            "| Configuration | Bandwidth Anomalies | Latency Anomalies | Packet Loss Anomalies | DNS Anomalies | Total |",
            "|---------------|---------------------|-------------------|----------------------|---------------|-------|",
        ];
        // Sort configurations alphabetically
        const sortedConfigs = Array.from(anomalyMap.keys()).sort();
        sortedConfigs.forEach(config => {
            const configAnomalies = anomalyMap.get(config) || new Map();
            // Format anomaly counts with severity
            const formatAnomalies = (type) => {
                if (!configAnomalies.has(type))
                    return '0';
                const anomalyData = configAnomalies.get(type);
                if (!anomalyData)
                    return '0';
                const { count, severities } = anomalyData;
                const severityCounts = {
                    high: severities.filter(s => s === 'high').length,
                    medium: severities.filter(s => s === 'medium').length,
                    low: severities.filter(s => s === 'low').length
                };
                const parts = [];
                if (severityCounts.high > 0)
                    parts.push(`${severityCounts.high} (high)`);
                if (severityCounts.medium > 0)
                    parts.push(`${severityCounts.medium} (medium)`);
                if (severityCounts.low > 0)
                    parts.push(`${severityCounts.low} (low)`);
                return parts.join(', ');
            };
            const bandwidthAnomalies = formatAnomalies('bandwidth');
            const latencyAnomalies = formatAnomalies('latency');
            const packetLossAnomalies = formatAnomalies('packet_loss');
            const dnsAnomalies = formatAnomalies('dns_failure');
            // Calculate total anomalies
            const totalAnomalies = Array.from(configAnomalies.values())
                .reduce((sum, anomalyData) => sum + anomalyData.count, 0);
            table.push(`| ${config} | ${bandwidthAnomalies} | ${latencyAnomalies} | ${packetLossAnomalies} | ${dnsAnomalies} | ${totalAnomalies} |`);
        });
        return table.join("\n");
    }
    generateDetailedTables(analysis) {
        const sections = [
            "## Detailed Performance Analysis",
            "",
            this.generateBandwidthTable(analysis.iperfAnalysis.bandwidthComparison),
            "",
            this.generateLatencyTable(analysis.iperfAnalysis.latencyAnalysis),
            "",
            this.generateReliabilityTable(analysis.iperfAnalysis.reliabilityMetrics),
            "",
            this.generateCpuUtilizationTable(analysis.iperfAnalysis.cpuUtilizationAnalysis),
            "",
            this.generateDnsPerformanceTable(analysis.dnsAnalysis.performanceMetrics),
            "",
            this.generateDomainRankingTable(analysis.dnsAnalysis.domainRankings),
            "",
            "## Advanced Performance Analysis",
            "",
            "These tables provide more detailed analysis of specific performance metrics to help identify patterns and correlations.",
            "",
            this.generateDetailedBandwidthAnalysis(analysis.iperfAnalysis.bandwidthComparison),
            "",
            this.generateJitterAnalysis(analysis.iperfAnalysis.latencyAnalysis),
            "",
            this.generateRetransmissionAnalysis(analysis.iperfAnalysis.reliabilityMetrics),
            "",
            this.generatePerformanceCorrelationMatrix(analysis),
        ];
        return sections.join("\n");
    }
    /**
     * Generate a table for bandwidth metrics
     * @param metrics The bandwidth metrics to tabulate
     * @returns The bandwidth table as a markdown string
     */
    generateBandwidthTable(metrics) {
        const table = [
            "### Bandwidth Performance",
            "",
            "The following table shows bandwidth performance metrics across different configurations:",
            "",
            "| Configuration | Avg (Mbps) | Median (Mbps) | Max (Mbps) | Min (Mbps) | Std Dev | 95th % | 99th % |",
            "|--------------|------------|---------------|------------|------------|---------|--------|--------|",
        ];
        metrics.forEach((metric) => {
            table.push(`| ${this.getConfigurationDisplayName(metric.configuration)} | ${metric.avgBandwidthMbps.toFixed(2)} | ${metric.medianBandwidthMbps.toFixed(2)} | ${metric.maxBandwidthMbps.toFixed(2)} | ${metric.minBandwidthMbps.toFixed(2)} | ${metric.standardDeviation.toFixed(2)} | ${metric.percentile95.toFixed(2)} | ${metric.percentile99.toFixed(2)} |`);
        });
        return table.join("\n");
    }
    /**
     * Generate a table for latency metrics
     * @param metrics The latency metrics to tabulate
     * @returns The latency table as a markdown string
     */
    generateLatencyTable(metrics) {
        const table = [
            "### Latency Performance",
            "",
            "The following table shows latency performance metrics across different configurations:",
            "",
            "| Configuration | Avg (ms) | Median (ms) | Max (ms) | Min (ms) | Jitter (ms) |",
            "|--------------|----------|-------------|----------|----------|-------------|",
        ];
        metrics.forEach((metric) => {
            table.push(`| ${this.getConfigurationDisplayName(metric.configuration)} | ${metric.avgLatencyMs.toFixed(2)} | ${metric.medianLatencyMs.toFixed(2)} | ${metric.maxLatencyMs.toFixed(2)} | ${metric.minLatencyMs.toFixed(2)} | ${metric.jitterMs.toFixed(2)} |`);
        });
        return table.join("\n");
    }
    /**
     * Generate a table for reliability metrics
     * @param metrics The reliability metrics to tabulate
     * @returns The reliability table as a markdown string
     */
    generateReliabilityTable(metrics) {
        const table = [
            "### Reliability Metrics",
            "",
            "The following table shows reliability metrics across different configurations:",
            "",
            "| Configuration | Success Rate (%) | Retransmit Rate (%) | Packet Loss (%) | Error Count |",
            "|--------------|------------------|---------------------|-----------------|-------------|",
        ];
        metrics.forEach((metric) => {
            table.push(`| ${this.getConfigurationDisplayName(metric.configuration)} | ${(metric.successRate * 100).toFixed(2)} | ${(metric.retransmitRate * 100).toFixed(2)} | ${(metric.packetLossRate * 100).toFixed(2)} | ${metric.errorCount} |`);
        });
        return table.join("\n");
    }
    /**
     * Generate a table for CPU utilization metrics
     * @param metrics The CPU metrics to tabulate
     * @returns The CPU utilization table as a markdown string
     */
    generateCpuUtilizationTable(metrics) {
        const table = [
            "### CPU Utilization",
            "",
            "The following table shows CPU utilization metrics across different configurations:",
            "",
            "| Configuration | Avg Host CPU (%) | Avg Remote CPU (%) | Max Host CPU (%) | Max Remote CPU (%) |",
            "|--------------|------------------|-------------------|------------------|-------------------|",
        ];
        metrics.forEach((metric) => {
            table.push(`| ${this.getConfigurationDisplayName(metric.configuration)} | ${(metric.avgHostCpuUsage * 100).toFixed(2)} | ${(metric.avgRemoteCpuUsage * 100).toFixed(2)} | ${(metric.maxHostCpuUsage * 100).toFixed(2)} | ${(metric.maxRemoteCpuUsage * 100).toFixed(2)} |`);
        });
        return table.join("\n");
    }
    /**
     * Generate a table for DNS performance metrics
     * @param metrics The DNS performance metrics to tabulate
     * @returns The DNS performance table as a markdown string
     */
    generateDnsPerformanceTable(metrics) {
        const table = [
            "### DNS Performance",
            "",
            "The following table shows DNS performance metrics across different configurations:",
            "",
            "| Configuration | Avg Response Time (ms) | Median Response Time (ms) | Success Rate (%) |",
            "|--------------|------------------------|---------------------------|------------------|",
        ];
        metrics.forEach((metric) => {
            table.push(`| ${this.getConfigurationDisplayName(metric.configuration)} | ${metric.avgResponseTimeMs.toFixed(2)} | ${metric.medianResponseTimeMs.toFixed(2)} | ${(metric.successRate * 100).toFixed(2)} |`);
        });
        return table.join("\n");
    }
    /**
     * Generate a table for domain ranking by performance
     * @param domains The domain performance metrics to tabulate
     * @returns The domain ranking table as a markdown string
     */
    generateDomainRankingTable(domains) {
        // Take top 10 slowest domains
        const slowestDomains = [...domains]
            .sort((a, b) => b.avgResponseTimeMs - a.avgResponseTimeMs)
            .slice(0, 10);
        const table = [
            "### Slowest DNS Domains",
            "",
            "The following table shows the 10 slowest domains by average response time:",
            "",
            "| Domain | Avg Response Time (ms) | Success Rate (%) | Query Count |",
            "|--------|------------------------|------------------|-------------|",
        ];
        slowestDomains.forEach((domain) => {
            table.push(`| ${domain.domain} | ${domain.avgResponseTimeMs.toFixed(2)} | ${(domain.successRate * 100).toFixed(2)} | ${domain.queryCount} |`);
        });
        return table.join("\n");
    }
    /**
     * Create textual descriptions of visualizations for the report
     * @param analysis The analysis results to describe
     * @returns The visualization descriptions as a markdown string
     */
    createVisualizationDescriptions(analysis) {
        const { iperfAnalysis, dnsAnalysis, configurationComparison } = analysis;
        const descriptions = [
            "## Performance Visualization Analysis",
            "",
            "### Bandwidth Comparison",
            "",
            this.describeBandwidthVisualization(iperfAnalysis.bandwidthComparison),
            "",
            "### MTU Impact Analysis",
            "",
            this.describeMtuImpact(configurationComparison.mtuImpact),
            "",
            "### DNS Performance Patterns",
            "",
            this.describeDnsPerformance(dnsAnalysis.performanceMetrics),
        ];
        return descriptions.join("\n");
    }
    /**
     * Describe bandwidth visualization insights
     * @param metrics The bandwidth metrics to describe
     * @returns The bandwidth visualization description
     */
    describeBandwidthVisualization(metrics) {
        if (!metrics || metrics.length === 0) {
            return "No bandwidth data available for visualization.";
        }
        // Sort configurations by average bandwidth
        const sortedByBandwidth = [...metrics].sort((a, b) => b.avgBandwidthMbps - a.avgBandwidthMbps);
        const bestConfig = sortedByBandwidth[0];
        const worstConfig = sortedByBandwidth[sortedByBandwidth.length - 1];
        if (!bestConfig || !worstConfig) {
            return "Insufficient bandwidth data for comparison.";
        }
        const bandwidthDifference = bestConfig.avgBandwidthMbps - worstConfig.avgBandwidthMbps;
        const percentageDifference = (bandwidthDifference / worstConfig.avgBandwidthMbps) * 100;
        const bestConfigName = this.getConfigurationDisplayName(bestConfig.configuration);
        const worstConfigName = this.getConfigurationDisplayName(worstConfig.configuration);
        return [
            `The bandwidth comparison chart shows that the **${bestConfigName}** configuration achieves the highest average bandwidth at **${bestConfig.avgBandwidthMbps.toFixed(2)} Mbps**. This is **${percentageDifference.toFixed(2)}%** higher than the lowest performing configuration (**${worstConfigName}** at **${worstConfig.avgBandwidthMbps.toFixed(2)} Mbps**).`,
            "",
            `The 95th percentile bandwidth for the best configuration is **${bestConfig.percentile95.toFixed(2)} Mbps**, indicating consistent high performance. The standard deviation of **${bestConfig.standardDeviation.toFixed(2)}** suggests ${bestConfig.standardDeviation < 5 ? "stable" : "variable"} performance across test runs.`,
        ].join("\n");
    }
    /**
     * Describe MTU impact analysis insights
     * @param mtuAnalysis The MTU analysis to describe
     * @returns The MTU impact description
     */
    describeMtuImpact(mtuAnalysis) {
        if (!mtuAnalysis) {
            return "No MTU analysis data available.";
        }
        const { optimalMtu, performanceByMtu, recommendations } = mtuAnalysis;
        if (!performanceByMtu || Object.keys(performanceByMtu).length === 0) {
            return `MTU analysis shows that ${optimalMtu || "N/A"} is the recommended MTU size, but detailed performance data is not available.`;
        }
        // Get MTU sizes and sort them
        const mtuSizes = Object.keys(performanceByMtu)
            .map(Number)
            .sort((a, b) => a - b);
        let description = [
            `Analysis of different MTU sizes shows that **${optimalMtu}** provides the optimal balance of performance metrics. `,
            "",
        ];
        // Add comparison between different MTU sizes
        if (mtuSizes.length > 1) {
            const comparisons = [];
            for (let i = 0; i < mtuSizes.length - 1; i++) {
                const currentMtu = mtuSizes[i];
                const nextMtu = mtuSizes[i + 1];
                if (typeof currentMtu === "number" &&
                    typeof nextMtu === "number" &&
                    performanceByMtu[currentMtu] &&
                    performanceByMtu[nextMtu]) {
                    const currentPerf = performanceByMtu[currentMtu];
                    const nextPerf = performanceByMtu[nextMtu];
                    const bandwidthDiff = ((nextPerf.avgBandwidth - currentPerf.avgBandwidth) /
                        currentPerf.avgBandwidth) *
                        100;
                    const latencyDiff = ((nextPerf.avgLatency - currentPerf.avgLatency) /
                        currentPerf.avgLatency) *
                        100;
                    comparisons.push(`Increasing MTU from **${currentMtu}** to **${nextMtu}** resulted in a **${bandwidthDiff.toFixed(2)}%** change in bandwidth and a **${latencyDiff.toFixed(2)}%** change in latency.`);
                }
            }
            if (comparisons.length > 0) {
                description = description.concat(comparisons);
                description.push("");
            }
        }
        // Add recommendations
        if (recommendations && recommendations.length > 0) {
            description.push("**Recommendations based on MTU analysis:**");
            description.push("");
            recommendations.forEach((rec) => {
                description.push(`- ${rec}`);
            });
        }
        return description.join("\n");
    }
    /**
     * Describe DNS performance insights
     * @param metrics The DNS performance metrics to describe
     * @returns The DNS performance description
     */
    describeDnsPerformance(metrics) {
        if (!metrics || metrics.length === 0) {
            return "No DNS performance data available for analysis.";
        }
        // Sort configurations by average response time
        const sortedByResponseTime = [...metrics].sort((a, b) => a.avgResponseTimeMs - b.avgResponseTimeMs);
        const bestConfig = sortedByResponseTime[0];
        const worstConfig = sortedByResponseTime[sortedByResponseTime.length - 1];
        if (!bestConfig || !worstConfig) {
            return "Insufficient DNS performance data for comparison.";
        }
        const timeDifference = worstConfig.avgResponseTimeMs - bestConfig.avgResponseTimeMs;
        const percentageDifference = (timeDifference / bestConfig.avgResponseTimeMs) * 100;
        const bestConfigName = this.getConfigurationDisplayName(bestConfig.configuration);
        const worstConfigName = this.getConfigurationDisplayName(worstConfig.configuration);
        return [
            `DNS performance analysis shows that the **${bestConfigName}** configuration achieves the fastest average response time at **${bestConfig.avgResponseTimeMs.toFixed(2)} ms**. This is **${percentageDifference.toFixed(2)}%** faster than the slowest configuration (**${worstConfigName}** at **${worstConfig.avgResponseTimeMs.toFixed(2)} ms**).`,
            "",
            `The success rate for DNS queries ranges from **${(bestConfig.successRate * 100).toFixed(2)}%** to **${(worstConfig.successRate * 100).toFixed(2)}%** across configurations.`,
            "",
            `Analysis of the slowest domains reveals patterns that may indicate network configuration issues or DNS server performance limitations. The slowest domains consistently show higher response times across all configurations.`,
        ].join("\n");
    }
    /**
     * Generate a section for performance anomalies
     * @param analysis The analysis results
     * @returns The anomalies section as a markdown string
     */
    generateAnomaliesSection(analysis) {
        const { anomalies } = analysis;
        if (!anomalies || anomalies.length === 0) {
            return "## Performance Anomalies\n\nNo significant performance anomalies were detected in the analyzed datasets.";
        }
        // First, update all anomaly configurations to use display names
        const updatedAnomalies = anomalies.map(anomaly => {
            return {
                ...anomaly,
                displayConfiguration: this.getConfigurationDisplayName(anomaly.configuration)
            };
        });
        const section = [
            "## Performance Anomalies",
            "",
            "The following performance anomalies were detected during analysis:",
            "",
        ];
        // Group anomalies by severity
        const highSeverity = updatedAnomalies.filter((a) => a.severity === "high");
        const mediumSeverity = updatedAnomalies.filter((a) => a.severity === "medium");
        const lowSeverity = updatedAnomalies.filter((a) => a.severity === "low");
        if (highSeverity.length > 0) {
            section.push("### High Severity Anomalies");
            section.push("");
            highSeverity.forEach((anomaly) => {
                section.push(this.formatAnomalyEntry(anomaly));
            });
        }
        if (mediumSeverity.length > 0) {
            section.push("### Medium Severity Anomalies");
            section.push("");
            mediumSeverity.forEach((anomaly) => {
                section.push(this.formatAnomalyEntry(anomaly));
            });
        }
        if (lowSeverity.length > 0) {
            section.push("### Low Severity Anomalies");
            section.push("");
            lowSeverity.forEach((anomaly) => {
                section.push(this.formatAnomalyEntry(anomaly));
            });
        }
        return section.join("\n");
    }
    /**
     * Format an anomaly entry for the report
     * @param anomaly The anomaly to format
     * @returns The formatted anomaly entry
     */
    formatAnomalyEntry(anomaly) {
        // Always use the display name for the configuration
        const configName = this.getConfigurationDisplayName(anomaly.configuration);
        const entry = [
            `#### ${anomaly.type.toUpperCase()} Anomaly in ${configName}`,
            "",
            `**Description:** ${anomaly.description}`,
            "",
            "**Affected Metrics:**",
        ];
        anomaly.affectedMetrics.forEach((metric) => {
            entry.push(`- ${metric}`);
        });
        entry.push("");
        entry.push("**Recommendations:**");
        anomaly.recommendations.forEach((rec) => {
            entry.push(`- ${rec}`);
        });
        entry.push("");
        return entry.join("\n");
    }
    /**
     * Generate a recommendations section for the report
     * @param analysis The analysis results
     * @returns The recommendations section as a markdown string
     */
    generateRecommendationsSection(analysis) {
        const { summary } = analysis;
        const section = [
            "## Recommendations",
            "",
            "Based on the comprehensive analysis of network performance across configurations, the following recommendations are provided:",
        ];
        // Add recommendations as bullet points
        summary.recommendations.forEach((recommendation) => {
            section.push(`- ${recommendation}`);
        });
        return section.join("\n");
    }
    /**
     * Generate advanced analysis tables for detailed performance metrics
     * @param analysis The analysis results
     * @returns The advanced analysis tables as a markdown string
     */
    generateAdvancedAnalysisTables(analysis) {
        console.log('[DEBUG] Generating advanced analysis tables');
        // Generate each section separately with debug logging
        const bandwidthAnalysis = this.generateDetailedBandwidthAnalysis(analysis.iperfAnalysis.bandwidthComparison);
        console.log('[DEBUG] Bandwidth analysis generated, length:', bandwidthAnalysis.length);
        const jitterAnalysis = this.generateJitterAnalysis(analysis.iperfAnalysis.latencyAnalysis);
        console.log('[DEBUG] Jitter analysis generated, length:', jitterAnalysis.length);
        const retransmissionAnalysis = this.generateRetransmissionAnalysis(analysis.iperfAnalysis.reliabilityMetrics);
        console.log('[DEBUG] Retransmission analysis generated, length:', retransmissionAnalysis.length);
        const correlationMatrix = this.generatePerformanceCorrelationMatrix(analysis);
        console.log('[DEBUG] Correlation matrix generated, length:', correlationMatrix.length);
        const sections = [
            "## Advanced Performance Analysis",
            "",
            "These tables provide more detailed analysis of specific performance metrics to help identify patterns and correlations.",
            "",
            bandwidthAnalysis,
            "",
            jitterAnalysis,
            "",
            retransmissionAnalysis,
            "",
            correlationMatrix,
        ];
        const result = sections.join("\n");
        console.log('[DEBUG] Advanced analysis tables complete, total length:', result.length);
        return result;
    }
    /**
     * Generate a detailed bandwidth analysis table
     * @param metrics The bandwidth metrics to analyze
     * @returns The detailed bandwidth analysis as a markdown string
     */
    generateDetailedBandwidthAnalysis(metrics) {
        // Calculate coefficient of variation for each configuration
        const metricsWithCv = metrics.map(metric => {
            const cv = metric.standardDeviation / metric.avgBandwidthMbps;
            return {
                ...metric,
                cv,
                displayName: this.getConfigurationDisplayName(metric.configuration)
            };
        });
        // Sort by coefficient of variation (stability)
        const sortedByCv = [...metricsWithCv].sort((a, b) => a.cv - b.cv);
        const table = [
            "### Detailed Bandwidth Analysis",
            "",
            "This table provides a detailed analysis of bandwidth performance, including stability metrics and percentile distribution:",
            "",
            "| Configuration | Avg (Mbps) | Median (Mbps) | Std Dev | CV (%) | Min (Mbps) | 25th % | 75th % | 95th % | 99th % | Max (Mbps) |",
            "|--------------|------------|---------------|---------|--------|------------|--------|--------|--------|--------|------------|",
        ];
        sortedByCv.forEach(metric => {
            // Calculate 25th and 75th percentiles (estimated)
            const range = metric.maxBandwidthMbps - metric.minBandwidthMbps;
            const percentile25 = metric.minBandwidthMbps + (range * 0.25);
            const percentile75 = metric.minBandwidthMbps + (range * 0.75);
            table.push(`| ${metric.displayName} | ${metric.avgBandwidthMbps.toFixed(2)} | ${metric.medianBandwidthMbps.toFixed(2)} | ${metric.standardDeviation.toFixed(2)} | ${(metric.cv * 100).toFixed(2)} | ${metric.minBandwidthMbps.toFixed(2)} | ${percentile25.toFixed(2)} | ${percentile75.toFixed(2)} | ${metric.percentile95.toFixed(2)} | ${metric.percentile99.toFixed(2)} | ${metric.maxBandwidthMbps.toFixed(2)} |`);
        });
        // Add analysis text
        table.push("");
        table.push("**Bandwidth Stability Analysis:**");
        table.push("");
        // Find most and least stable configurations
        const mostStable = sortedByCv[0];
        const leastStable = sortedByCv[sortedByCv.length - 1];
        table.push(`- The **${mostStable.displayName}** configuration shows the most stable bandwidth with a coefficient of variation (CV) of ${(mostStable.cv * 100).toFixed(2)}%.`);
        table.push(`- The **${leastStable.displayName}** configuration shows the least stable bandwidth with a coefficient of variation (CV) of ${(leastStable.cv * 100).toFixed(2)}%.`);
        table.push(`- Lower CV values indicate more consistent bandwidth performance across test runs.`);
        return table.join("\n");
    }
    /**
     * Generate a jitter analysis table
     * @param metrics The latency metrics to analyze
     * @returns The jitter analysis as a markdown string
     */
    generateJitterAnalysis(metrics) {
        // Calculate jitter to latency ratio for each configuration
        const metricsWithRatio = metrics.map(metric => {
            const jitterLatencyRatio = metric.jitterMs / metric.avgLatencyMs;
            return {
                ...metric,
                jitterLatencyRatio,
                displayName: this.getConfigurationDisplayName(metric.configuration)
            };
        });
        // Sort by jitter
        const sortedByJitter = [...metricsWithRatio].sort((a, b) => a.jitterMs - b.jitterMs);
        const table = [
            "### Jitter Analysis",
            "",
            "This table analyzes jitter (latency variation) across configurations and its relationship to average latency:",
            "",
            "| Configuration | Jitter (ms) | Avg Latency (ms) | Jitter/Latency Ratio | Max Latency (ms) | Min Latency (ms) | Latency Range (ms) |",
            "|--------------|-------------|------------------|----------------------|-----------------|-----------------|-------------------|",
        ];
        sortedByJitter.forEach(metric => {
            const latencyRange = metric.maxLatencyMs - metric.minLatencyMs;
            table.push(`| ${metric.displayName} | ${metric.jitterMs.toFixed(2)} | ${metric.avgLatencyMs.toFixed(2)} | ${metric.jitterLatencyRatio.toFixed(4)} | ${metric.maxLatencyMs.toFixed(2)} | ${metric.minLatencyMs.toFixed(2)} | ${latencyRange.toFixed(2)} |`);
        });
        // Add analysis text
        table.push("");
        table.push("**Jitter Impact Analysis:**");
        table.push("");
        // Find configurations with lowest and highest jitter
        const lowestJitter = sortedByJitter[0];
        const highestJitter = sortedByJitter[sortedByJitter.length - 1];
        table.push(`- The **${lowestJitter.displayName}** configuration has the lowest jitter at ${lowestJitter.jitterMs.toFixed(2)} ms, indicating the most stable latency performance.`);
        table.push(`- The **${highestJitter.displayName}** configuration has the highest jitter at ${highestJitter.jitterMs.toFixed(2)} ms, indicating more variable latency.`);
        table.push(`- The Jitter/Latency Ratio indicates how significant the jitter is relative to the average latency. Lower values indicate more consistent performance.`);
        return table.join("\n");
    }
    /**
     * Generate a retransmission analysis table
     * @param metrics The reliability metrics to analyze
     * @returns The retransmission analysis as a markdown string
     */
    generateRetransmissionAnalysis(metrics) {
        // Sort by retransmit rate
        const sortedByRetransmit = [...metrics].map(metric => ({
            ...metric,
            displayName: this.getConfigurationDisplayName(metric.configuration)
        })).sort((a, b) => a.retransmitRate - b.retransmitRate);
        const table = [
            "### Retransmission Analysis",
            "",
            "This table analyzes TCP retransmission rates and their correlation with packet loss and success rates:",
            "",
            "| Configuration | Retransmit Rate (%) | Packet Loss (%) | Success Rate (%) | Error Count | Retransmit/Loss Ratio |",
            "|--------------|---------------------|-----------------|------------------|-------------|------------------------|",
        ];
        sortedByRetransmit.forEach(metric => {
            // Calculate retransmit to packet loss ratio (if packet loss is not zero)
            const retransmitLossRatio = metric.packetLossRate > 0
                ? (metric.retransmitRate / metric.packetLossRate).toFixed(2)
                : 'N/A';
            table.push(`| ${metric.displayName} | ${(metric.retransmitRate * 100).toFixed(2)} | ${(metric.packetLossRate * 100).toFixed(2)} | ${(metric.successRate * 100).toFixed(2)} | ${metric.errorCount} | ${retransmitLossRatio} |`);
        });
        // Add analysis text
        table.push("");
        table.push("**Retransmission Impact Analysis:**");
        table.push("");
        // Find configurations with lowest and highest retransmit rates
        const lowestRetransmit = sortedByRetransmit[0];
        const highestRetransmit = sortedByRetransmit[sortedByRetransmit.length - 1];
        table.push(`- The **${lowestRetransmit.displayName}** configuration has the lowest retransmission rate at ${(lowestRetransmit.retransmitRate * 100).toFixed(2)}%.`);
        table.push(`- The **${highestRetransmit.displayName}** configuration has the highest retransmission rate at ${(highestRetransmit.retransmitRate * 100).toFixed(2)}%.`);
        table.push(`- The Retransmit/Loss Ratio indicates how efficiently TCP recovers from packet loss. Higher values suggest more aggressive retransmission strategies.`);
        return table.join("\n");
    }
    /**
     * Generate a performance correlation matrix
     * @param analysis The analysis results
     * @returns The performance correlation matrix as a markdown string
     */
    generatePerformanceCorrelationMatrix(analysis) {
        const { iperfAnalysis, dnsAnalysis } = analysis;
        const { bandwidthComparison, latencyAnalysis, reliabilityMetrics } = iperfAnalysis;
        // Create a combined dataset for correlation analysis
        const combinedData = [];
        // Process each configuration
        analysis.configurationComparison.overallRanking.forEach(ranking => {
            const config = ranking.configuration;
            const displayName = this.getConfigurationDisplayName(config);
            // Find corresponding metrics
            const bandwidthMetric = bandwidthComparison.find(m => m.configuration === config);
            const latencyMetric = latencyAnalysis.find(m => m.configuration === config);
            const reliabilityMetric = reliabilityMetrics.find(m => m.configuration === config);
            const dnsMetric = dnsAnalysis.performanceMetrics.find(m => m.configuration === config);
            if (bandwidthMetric && latencyMetric && reliabilityMetric && dnsMetric) {
                combinedData.push({
                    configuration: displayName,
                    bandwidth: bandwidthMetric.avgBandwidthMbps,
                    latency: latencyMetric.avgLatencyMs,
                    jitter: latencyMetric.jitterMs,
                    packetLoss: reliabilityMetric.packetLossRate * 100,
                    retransmitRate: reliabilityMetric.retransmitRate * 100,
                    dnsResponseTime: dnsMetric.avgResponseTimeMs,
                    overallScore: ranking.overallScore
                });
            }
        });
        // Create correlation matrix table
        const table = [
            "### Performance Metric Correlation Matrix",
            "",
            "This table shows the relationships between different performance metrics across configurations:",
            "",
            "| Metric | Bandwidth | Latency | Jitter | Packet Loss | Retransmit Rate | DNS Response Time | Overall Score |",
            "|--------|-----------|---------|--------|-------------|-----------------|-------------------|---------------|",
        ];
        // Define metrics to correlate
        const metrics = [
            { name: 'Bandwidth', key: 'bandwidth', unit: 'Mbps', higherIsBetter: true },
            { name: 'Latency', key: 'latency', unit: 'ms', higherIsBetter: false },
            { name: 'Jitter', key: 'jitter', unit: 'ms', higherIsBetter: false },
            { name: 'Packet Loss', key: 'packetLoss', unit: '%', higherIsBetter: false },
            { name: 'Retransmit Rate', key: 'retransmitRate', unit: '%', higherIsBetter: false },
            { name: 'DNS Response Time', key: 'dnsResponseTime', unit: 'ms', higherIsBetter: false },
            { name: 'Overall Score', key: 'overallScore', unit: '', higherIsBetter: true }
        ];
        // For each metric, calculate its relationship with other metrics
        metrics.forEach(metric => {
            const row = [`**${metric.name}**`];
            metrics.forEach(otherMetric => {
                if (metric.key === otherMetric.key) {
                    row.push('1.00'); // Perfect correlation with itself
                }
                else {
                    // Find best and worst configurations for this metric
                    const sortFunc = metric.higherIsBetter ?
                        (a, b) => b[metric.key] - a[metric.key] :
                        (a, b) => a[metric.key] - b[metric.key];
                    const sortedConfigs = [...combinedData].sort(sortFunc);
                    const bestConfig = sortedConfigs[0];
                    const worstConfig = sortedConfigs[sortedConfigs.length - 1];
                    // Check if the best config for this metric is also good for the other metric
                    const bestConfigOtherMetricValue = bestConfig[otherMetric.key];
                    const worstConfigOtherMetricValue = worstConfig[otherMetric.key];
                    // Calculate a simple correlation indicator (-1 to 1)
                    // If the best config for this metric is also the best for the other metric, correlation is positive
                    // If the best config for this metric is the worst for the other metric, correlation is negative
                    let correlation;
                    if (otherMetric.higherIsBetter) {
                        // For metrics where higher is better
                        const otherMetricRange = Math.max(...combinedData.map(d => d[otherMetric.key])) -
                            Math.min(...combinedData.map(d => d[otherMetric.key]));
                        if (otherMetricRange === 0) {
                            correlation = 0; // No variation in the other metric
                        }
                        else {
                            correlation = (bestConfigOtherMetricValue - worstConfigOtherMetricValue) / otherMetricRange;
                        }
                    }
                    else {
                        // For metrics where lower is better
                        const otherMetricRange = Math.max(...combinedData.map(d => d[otherMetric.key])) -
                            Math.min(...combinedData.map(d => d[otherMetric.key]));
                        if (otherMetricRange === 0) {
                            correlation = 0; // No variation in the other metric
                        }
                        else {
                            correlation = (worstConfigOtherMetricValue - bestConfigOtherMetricValue) / otherMetricRange;
                        }
                    }
                    // Format correlation value
                    row.push(correlation.toFixed(2));
                }
            });
            table.push(`| ${row.join(' | ')} |`);
        });
        // Add analysis text
        table.push("");
        table.push("**Correlation Analysis:**");
        table.push("");
        table.push("- Values close to 1.00 indicate strong positive correlation (metrics tend to improve together)");
        table.push("- Values close to -1.00 indicate strong negative correlation (one metric improves while the other degrades)");
        table.push("- Values close to 0.00 indicate little or no correlation between metrics");
        table.push("- This analysis helps identify which performance aspects are most important to optimize for your specific use case");
        return table.join("\n");
    }
}
exports.DefaultReportGenerator = DefaultReportGenerator;
//# sourceMappingURL=ReportGenerator.js.map